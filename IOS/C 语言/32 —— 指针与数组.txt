



指针与数组
-------------------------------------------------------------------------------------------------------------------

※ 指针与整数间的加减运算。
     比如 指针+1
     并不是在指针地址的基础之上加1个字节的地址，而是在这个指针地址的基础上加1个单位
     变量的占用的字节数
     
     如果指针的类型是int*,那么这个时候1代表4个字节地址.
     如果指针的类型是float*,那么这个时候1代表4个字节地址.
     如果指针的类型是double*,那么这个时候1代表8个字节地址.
     如果指针的类型是char*,那么这个时候1代表1个字节地址.
     
     int num1 = 10;
     int num2 = 20;
     int *p1 = &num2;
     int *p2 = p1 + 1;
     printf("p1 = %p\n", &p1); //p1 = 0x1121
     printf("p2 = %p\n", &p2); //p2 = 0x1125 在原基础上加了4个地址。也就是一个int字节
     printf("*p2 = %d\n", *p2);//*p2 = 10 = num1;


※ 使用指针来遍历数组

     int arr[7] = {10,20,30,40,50,60,70};

     1).方式一
        int *p1 = arr;//p1指针指向了数组的第0个元素
        for(int i =0; i<7; i++)
        {
	   printf("%d\n", *(p1+i));
        }
     
     2).方式二
        for(int i =0; i<7; i++)
        {
	   printf("%d\n", *(arr+1));
        }

     3).方式三
        int *p1 = arr;//p1指针指向了数组的第0个元素
        for(int i =0; i<7; i++)
        {
	   printf("%d\n", *(p1++));
        }
   


 ※ 数组作为函数的参数是地址传递的本质。
     当我们数组作为函数参数的时候，在编译阶段，编译器自动把数组换成了指针，
     这也就是为什么我们通过sizeof得到的永远都是8.
     所以，以后我们的函数参数是数组的时候，建议不要写数组了，直接写这个数组的
     指针，和这个数组的长度。实际上，源码也是这样写的。
     void test(int *arr, int len)
     {
	 .......
     }
 
     
 
 ※ 指针中[]使用的本质
     p1[n]: 完全等价于 *(p1+n); 前提是p1是1个指针变量

   例一：
     int num1 = 10;
     int num2 = 20;
     int *p1 = &num2;

     p1[0] = 1000; //等价于 *(p1+0) = 1000;
     p1[1] = 2000; //等价于 *(p1+1) = 2000;

     printf("num2=%d\b",num2); //num2=1000
     printf("num1=%d\b",num1); //num1=2000
    

   例二： 
     int arr[5] = {10,20,30,40,50};

     *arr = 100;
     printf("arr[0]=%d\b",arr[0]); //arr[0]=1000

     arr[0] =100; //*(arr+0)
     arr[1] =200; //*(arr+1)=200
     arr[2] =300; //*(arr+2)=300



 ※ 指针数组
     int arr[3] = {10,20,30};
     int *pArr[3] = {arr[0],arr[1],arr[2]};

     *(pArr[0]) = 100;//arr数组的第0个元素. 
     printf("arr[0]=%d\b",arr[0]); //arr[0]=100

     int num = 1000;
     pArr[1] = &num;
     *(pArr[1]) = 2000;
     printf(num = %d\n", num); //2000

     

 ※ 指针与指针之间的减法运算
    int arr[] = {10,20,30,40,50,60,70,80,90,100};
    int *p1 = &arr[1]; 
    int *p2 = &arr[7]; 
    long res = p2 - p1;
    printf(res = %ld\n", res); //6
    
    指针相减：计算两个元素之间相差多少个元素。返回long类型。
              用在数组中，其他数据中用无意义。



 ※ 指针之间的比较运算
    > < >= <= == != 符号。可以判断两个指针指向的变量的地址字节高低，返回0和1.0代表假，1代表真
    
    int num1 = 10; //在高地址
    int num2 = 20; //在低地址

    int *p1 = &num1;
    int *p2 = &num2;

    int res = p2 > p1; //p2的值是否大于p1的值
    printf(res = %d\n", res); //res = 0 结果为假，表示 p2在低字节，p1在高字节


-------------------------------------------------------------------------------------------------------------------



