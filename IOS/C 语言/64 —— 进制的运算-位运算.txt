




位运算
-------------------------------------------------------------------------------------------------------------------

※ 位运算
    指的是1个二进制数据的每一位参与运算
    位运算的前提：是这个数必须是1个二进制

    注意：
     1.参与位运算的二进制数据必须是补码形式。
     2.位运算的结构也是二进制的补码形式。


-------------------------------------------------------------------------------------------------------------------




按位与：& 运算
-------------------------------------------------------------------------------------------------------------------

 ※ 按位与：&
     参与&的两个二进制数，如果都为1，那么结果为1，只要有1位为0，那么结果为0.
     如果结果为负数，则要还原到原码才是正确的结果


     3 & 2：
       3的补码  00000000 00000000 00000000 00000011
       2的补码  00000000 00000000 00000000 00000010
     ----------------------------------------------
        结果    00000000 00000000 00000000 00000010 2


     -3 & 4：
      -3的补码  11111111 11111111 11111111 11111101
       4的补码  00000000 00000000 00000000 00000100
    ----------------------------------------------
       结果     00000000 00000000 00000000 00000100 4


     -3 & -4：
      -3的补码  11111111 11111111 11111111 11111101
      -4的补码  11111111 11111111 11111111 11111100
    ----------------------------------------------
       结果     11111111 11111111 11111111 11111100
       反码：   11111111 11111111 11111111 11111011
       原码：   10000000 00000000 00000000 00000100 -4




 ※ &的应用，判断奇偶数:

     任何数 & 1：
       x的补码  xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx
       1的补码  00000000 00000000 00000000 00000001
     ----------------------------------------------
        结果    00000000 00000000 00000000 0000000x

     偶数位的最低位一定是0，所以 偶数&1=0
     奇数位的最低位一定是1，所以 奇数&1=1
     如果结果为1，那么就是奇数，如果结果为0，那么就是偶数

     int num = 10;
     if((num & 1) == 0){
        偶数;
     }else{
        奇数;
     }

-------------------------------------------------------------------------------------------------------------------



按位或：| 运算
-------------------------------------------------------------------------------------------------------------------

 ※ 按位或：|
     参与|的两个二进制数，如果只要有1位是1 那么结果就为1 只有当两位都是0的时候结果才为0
     如果结果为负数，则要还原到原码才是正确的结果


     3 | 2：
       3的补码  00000000 00000000 00000000 00000011
       2的补码  00000000 00000000 00000000 00000010
     ----------------------------------------------
        结果    00000000 00000000 00000000 00000011 3


     -3 & 4：
      -3的补码  11111111 11111111 11111111 11111101
       4的补码  00000000 00000000 00000000 00000100
    ----------------------------------------------
       结果     11111111 11111111 11111111 11111101
       反码：   11111111 11111111 11111111 11111100
       原码：   10000000 00000000 00000000 00000011 -3

     -3 & -4：
      -3的补码  11111111 11111111 11111111 11111101
      -4的补码  11111111 11111111 11111111 11111100
    ----------------------------------------------
       结果     11111111 11111111 11111111 11111101
       反码：   11111111 11111111 11111111 11111100
       原码：   10000000 00000000 00000000 00000011 -3



-------------------------------------------------------------------------------------------------------------------



按位取反：~ 运算
-------------------------------------------------------------------------------------------------------------------

 ※ 按位取反：~
     单目运算符,将这个二进制数的每一位取反
     如果结果为负数，则要还原到原码才是正确的结果

     ~3：
      3的补码  00000000 00000000 00000000 00000011
     ----------------------------------------------
       结果   11111111 11111111 11111111 11111100
       反码： 11111111 11111111 11111111 11111011
       原码： 10000000 00000000 00000000 00000100 -4


-------------------------------------------------------------------------------------------------------------------



按位异或：^ 运算
-------------------------------------------------------------------------------------------------------------------

 ※ 按位异或：^
     参与^的二进制数据的位，如果相同则为0 不同为1.
     如果结果为负数，则要还原到原码才是正确的结果

     3 ^ 2：
       3的补码  00000000 00000000 00000000 00000011
       2的补码  00000000 00000000 00000000 00000010
     ----------------------------------------------
        结果    00000000 00000000 00000000 00000001 1


 ※ 交换两个变量的值可以用异或运算。
     int a = 3;
     int b = 2;

     a = a ^ b; a = 1
     b = a ^ b; b = 3
     a = a ^ b; a = 2


-------------------------------------------------------------------------------------------------------------------




按位左移.：<< 运算
-------------------------------------------------------------------------------------------------------------------

 ※ 按位左移运算：
     参与<<的二进制数据.向左移动指定的位数。低位补0 高位溢出丢弃.

     3 << 2：
       3的补码  00000000 00000000 00000000 00000011
     ----------------------------------------------
        结果    00000000 00000000 00000000 00001100 12


     注意：
      1.左移运算有可能会改变其正负性
      2.将1个数左移n位，相当于将这个数 乘以 2的n次方
      3<<2  3乘以2的2次方  3*4=12
      16<<3 16乘以2的3次方 16*8=128

      5*16与5<<4肯定是<<更快效率更高
      更多是为了效率更高


-------------------------------------------------------------------------------------------------------------------



按位右移.：>> 运算
-------------------------------------------------------------------------------------------------------------------

 ※ 按位右移运算：
     参与>>的二进制数据.向右移动指定的位数。低位溢出丢弃 高位补符号位

     3 >> 2：
       3的补码  00000000 00000000 00000000 00000011
     ----------------------------------------------
        结果    00000000 00000000 00000000 00000000 0


     -16 >> 3：
     -16的补码  11111111 11111111 11111111 11110000
    ----------------------------------------------
       结果     11111111 11111111 11111111 11111110
       反码：   11111111 11111111 11111111 11111101
       原码：   10000000 00000000 00000000 00000010 2

     注意：
      1.右移运算不会改变正负性.
      2.1个数右移n位，相当于将这个数 除以 2的n次方
      100<<2  100除以2的2次方  100/4 效率更高

-------------------------------------------------------------------------------------------------------------------

