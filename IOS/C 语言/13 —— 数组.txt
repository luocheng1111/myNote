




数组. Array
-------------------------------------------------------------------------------------------------------------------

※ 数组的声明和赋值
    方式一：
     int arr[3]; //当声明1个数组，且没有为元素赋初始值时，那么元素的值是辣鸡值
     arr[0] = 100;
     arr[1] = 200;
     arr[2] = 50;
     printf("%d\b", arr[2]); //50
    
    方式二：声明的同时初始化数组的元素，但这种方式不允许数组长度是1个变量
     int arr[3] = {10, 20, 30};

    方式三：会根据大括弧的数据个数决定数据的长度
     int arr[] = {10,20,5,54,54,641,468,54};


※ 数组的长度
    sizeof(arr)/sizeof(arr[0]) 
    sizeof(arr)/sizeof(元素类型)


※ 数组的遍历   
   int len = sizeof(arr)/sizeof(arr[0]);
   for(int i=0; i<len; i++){
	     printf("%d\b", arr[i]);
   }


-------------------------------------------------------------------------------------------------------------------



数组在内存中的存储方式
-------------------------------------------------------------------------------------------------------------------

※ 数组在内存中是如何存储的呢？
    比如： int arr[3] = {10, 20, 33};

    1.声明1个数组，在内存中从高字节想低字节申请连续的(数组的长度*每1个元素的字节数)个字节
      的空间。上面arr申请3*4=12个字节的控件

    2.下标为0的元素在低字节。最末位的元素在最高字节。

    3.元素的值还是按照之前那样 存储的是 数据的二进制的补码

    4.数组的元素的本质就是1个普通类型的变量。
      1个数组就是由多个普通类型的变量联合而成的。
      每1个元素就是1个普通变量，所以每1个元素也有自己的地址
     
    5.数组的地址是数组中最低字节的地址，也就是arr[0]的地址
     
    6.数组名存储这数组的地址。所以printf("arr的地址是%p", arr);得到是数组的地址，也是arr[0]的地址


    假如上方的arr申请的12个字节地址分别是0x111 0x112 到 0x11c
    则arr[0]的%p  是  0x111
      arr[1]的%p  是  0x115
      arr[2]的%p  是  0x119
      arr数组的%p  是  0x11c


-------------------------------------------------------------------------------------------------------------------



二维数组. 
-------------------------------------------------------------------------------------------------------------------

※ 二维数组的声明和赋值
    方式一：
     int arr[3][4]; //声明了一个3行4列的表格
  
     arr[0][0] = 10;
     arr[0][1] = 20;
     ...
     arr[1][0] = 100;
     ...
     arr[2][0] = 1000;
     ...
     printf("%d\b", arr[1][0]); //100

    方式二：声明的同时初始化数组的元素，但这种方式不允许数组长度是1个变量
     int arr[3][4] = {{10, 20, 30, 40},{100, 200, 300, 400},{1000, 2000, 3000, 4000}};
    
    方式三：会根据大括弧的数据个数决定数据的长度
     int arr[][4] ={{10, 20, 30, 40},{100, 200, 300, 400},{1000, 2000, 3000, 4000}};

    方式四：上面的初始化方式，可以省略行数，编译器自动计算行数。
     int arr[][4] ={10, 20, 30, 40, 100, 200, 300, 400, 1000, 2000, 3000, 4000};


※ 二维数组的长度(元素的个数)、行数、列数
     int len =  sizeof(arr)/sizeof(int);
     int rows = sizeof(arr)/sizeof(arr[0]);
     int clos = sizeof(arr[0])/sizeof(int);


※ 二维数组的遍历   
   int len = sizeof(arr)/sizeof(int);
   int rows = sizeof(arr)/sizeof(arr[0]);
   int clos = sizeof(arr[0])/sizeof(int);
   for(int i=0; i<rows; i++){
     for(int j=0; i<clos; i++){
        printf("%d\n", arr[i][i]);
     }
   }


※ 二维数组在内存中的存储
    二维数组的本质是多个一维数组。只不过，这个一维数组的每一个元素的类型又是1个数组

 
※ 二维数组的地址
    二维数组的地址就是这个二维数组的低字节的地址也就是arr[0][0]元素的地址
    二维数组名 就代表 这个二维数组的地址。
    可以用下面三中表示
    printf("%p\n",arr);
    printf("%p\n",arr[0]);
    printf("%p\n",&arr[0][0]);
 

 ※ 二维数组作为参数传递
    二维数组作为参数传递同一维数组一样，会丢失行和列
    且作为参数时，行数和省，列数必须要写
    解决方案:
    void test2(int rows, int cols, int arr[][clos]);

-------------------------------------------------------------------------------------------------------------------



数组作为函参
-------------------------------------------------------------------------------------------------------------------

※ 介绍
   当函参味一个数组时，在函数内部通过sizeof计算字节数时，会发现数组的长度声明为多大，得到的永远都是8个字节
   这个时候通过sizeof计算数组长度，是算不出来的
   
   原因：因为数组传值传的是数组的地址，这个地址占8个字节。所以sizeof计算得到的永远都是8
   解决：当数组作为参数的时候，同时也把数组的长度传递过来 
     

※ 写法：
   void testArr(int arr[], int len);
  
    int main(){
       int arr[] = {10,154,154,112,234,1361,121};
       testArr(arr, sizeof(arr)/sizeof(arr[0]));
    }

    void testArr(int arr[], int len){
       for(int i=0; i<len; i++){
          printf("%d\n", arr[i]);
       }
    }

-------------------------------------------------------------------------------------------------------------------
