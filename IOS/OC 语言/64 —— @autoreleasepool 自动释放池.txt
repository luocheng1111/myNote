


@autoreleasepool 自动释放池
--------------------------------------------------------------------------------------------------------

 ※ 自动释放池的介绍
    存入到自动释放池中对象，在自动释放池被销毁的时候，会自动调用存储在该自动释放池中的所有对象的release方法

    可以解决的问题：
    将创建的对象，存入到自然释放池之中，就不在需要手动的release这个对象了。
    因为池子销毁的时候 就会自动的调用池中所有的对象的relase
  
    自动释放池的好处：将创建的对象存储到自动释放池中，不需要再写release


 ※ 如何创建自动释放池
    @autoreleaspool
    {

    }
  

 ※ 如何将对象存储到自动释放池之中
    在自动释放池之中调用对象的autorelease方法。就会将这个对象存入到当前自动释放池之中。
    这个autorealse方法返回的是对象本身。所以，我们可以这么写
    @autoreleaspool
    {
      Person *p1 = [[[Person alloc] init] autorelease];
    }
  
    这个时候，当这个自动释放池执行完毕之后，就会立即为这个自动释放池中的对象发送1条release消息。
  
    目前为止，我们感受到得autorelase的好处：
    创建对象，调用对象的autorelase方法 将这个对象存入到当前的自动释放池之中。

    我们就不需要再去relase 因为自动释放池销毁的时候 就会自动的调用池中所有对象的relase


 ※ autorelease的应用场景。
    1). 创建对象，将对象存储懂啊自动释放池之中，就不需要再去手动的realse。

    2). 我们一般情况下，会为我们的类写1个类方法，用来让外界调用类方法来快速的得到1个对象。
        规范：使用类方法得到的对象，要球这个对象就已经被autorelease过了。

        提供1个类方法来快速的得到1个对象。
        规范
        a. 这个类方法以类名开头。 如果没有参数就直接是类名 如果有参数就是 类名WithXX：
        b. 使用类方法得到的对象，要求这个对象就已经被autorelease过了。

        + (instancetype)person
        {
	  return [[[self alloc] init] autotelease];
        }

        这样，我们直接调用类方法，就可以得到1个已经被autorelease过的对象。
        @autoreleasepool
        {
	  Person *p1 = [Person person];
	  //这个p1对象已经被autorelease过了，不需要再调用autorelease
	  //这个p1对象就被存储到当前自动释放池之中。
        }//当自动释放池结束。就会为存储在其中的p1对象放松release消息、



 ※ 实际上Apple的框架中的类也是遵守这个规范的。
    通过类方法创建的对象都是已经被autorelease过的了。
    所以，我们也要遵守这个规范， 类方法返回的对象也要被autorelease过。
    以后，我们凡事创建对象是调用类方法创建的对象 这个对象已经是被autorelease过的了。


 ※ 使用注意
    1).只有在自动释放池中调用了对象的autorelease方法，这个对象才会被存储到这个自动释放池之中。
       如果只是将对象的创建代码写在自动释放池之中，而没有调用对象的autorelease方法，是不会将这个对象存储到
       这个自动释放池之中的。
  
    2).对象的创建可以在自动释放池外面，在自动释放池之中，调用对象的autorelease方法，就可以将这个对象存储到
       自动释放池之中
  
    3).如果对象的autorelease方法的调用放在自动释放池的外面，是无法将其存储的这个自动释放池之中的。
       autorelease 的调用只有放在自动释放池之中 才可以将其存储到自动释放池之中，对象的创建可以在外面
  
    4).当自动释放池结束的时候，仅仅是对存储在自动释放池中的对象发送1条release消息 而不是销毁对象。

    5).如果在自动释放池中，调用同1个对象的autorelease方法多次，就会将对象存储多次到自动释放池之中。
       在自动释放池结束的时候，会为对象发送多条release消息，那么这个时候就会出现僵尸对象错误。
       所以，1个自动释放池之中，autorelease一次，就将这个对象释放一次，否则就会出现野指针错误。

    6).如果在自动释放池中，调用了存储到自动释放池中的对象的release方法。
       在自动释放池结束的时候，还会再调用对象的releas方法。
       这个时候就有可能造成野指针操作
       也可以调用存储在自动释放池中的对象的retain方法。

    7).将对象存储到自动释放池，并不会使对象的引用计数器+1
       所以其好处就是：创建对象将对象存储在自动释放池，就不需要在写个release了。
     
    8).自动释放池可以嵌套
       调用对象的autorelease方法，会将对象加入到当前自动释放池之中
       只有在当前自动释放池结束的时候才会像对象发送release消息。
  
 
--------------------------------------------------------------------------------------------------------

