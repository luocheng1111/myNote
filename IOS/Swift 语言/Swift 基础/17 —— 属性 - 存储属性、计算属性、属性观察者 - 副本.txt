

Swift 属性介绍
---------------------------------------------------------------------------------------------------
※ 介绍
    Swif属性分为 存储属性、计算属性
    存储属性分为实例存储属性、类型存储属性、延迟存储属性
    枚举不能定义实例存储属性、可以定义类型存储属性

---------------------------------------------------------------------------------------------------



存储属性
---------------------------------------------------------------------------------------------------
 ※ 什么是存储属性
     类、结构体中的常量、变量就叫是实例存储属性、枚举不能定义实例存储属性
     存储属性：存储一个值
    
    class Person{
	let name:String = "luocheng"
	var age:Int = 25
	var animal:Animal = Dog()
    }


---------------------------------------------------------------------------------------------------



类型存储属性、类型方法
---------------------------------------------------------------------------------------------------
 ※ 什么是类型存储属性、类型方法
     存储属性：static声明的存储属性
     类型方法：static声明的方法

 ※ 例子：
     class Player{
	let name:String
	var score = 0
	static var heightScore = 0  //类型存储属性

	func play(){
	    let score = random()*100
	    self.score = score
	    if self.score > Player.heightScore {
		Player.heightScore = self.score //Player不能省略
	    }
	}
     }

---------------------------------------------------------------------------------------------------




延迟存储属性 lazy
---------------------------------------------------------------------------------------------------
 ※ 什么是延迟存储属性
     当被使用时才会被计算初始值的属性，需要用lazy修饰
     当某一个属性初始化时很耗时间时，可考虑用lazy属性
    
    class User{
      lazy var person = Person(name:"luocheng"); //此属性初始化需要2秒
      var name = "aaa"
    }

    User user = User();
    print(user.name) //若没勇lazy修饰时，会延时2秒才会输出此值，加了lazy后，秒输出此值
    print(user.person.name) //会延迟2秒后，才会输出此值

---------------------------------------------------------------------------------------------------




计算属性 
---------------------------------------------------------------------------------------------------
 ※ 为什么有计算属性，什么是计算属性, 
     有时候类或结构体中只有存储属性是不方便的，有时候某属性需要根据其他属性值的改变而发生改变，所以有了存储属性
     相当于Obnject-C、Java等语言通过getter、setter合成的属性,
     枚举、类、结构体都可以定义计算属性
    

 ※ 例子：定义一个计算属性例子
    class User{
      var firshName:String
      var endName:String

      var fullName:String
      {
        get{
            return firshName + "-" + endName;
        }
        set(newValue){
            // can do some panduan
            var names = newValue.componentsSeparatedByString("-");
            self.firshName = names[0]
            self.endName = names[1]
        }
      }

    }
    
    get：不接受任何形参,里面是一段可执行的代码，最终将返回改计算属性的值，
         调用此属性时进入此方法，相当于Java中的 getter()
    set：必须带一个类型与计算属性类型匹配的形参, 里面的方法用于给计算属性赋值
         给此属性赋值时进入此方法，相当于Java中的 setter()  
	 此方法可以简化，可不写newValue
	 set{
            var names = newValue.componentsSeparatedByString("-");
            self.firshName = names[0]
            self.endName = names[1]
         }
    nil：有时候也可以不写set和get, 
         var fullName:String{
	    return firshName + "-" + endName;
         }
 

 ※ 声明计算属性注意点
      1.计算属性需要用var，不能用let
      2.计算属性需要显示的声明其类型

---------------------------------------------------------------------------------------------------




属性观察者
---------------------------------------------------------------------------------------------------
 ※ 属性观察者
     保护数据合法，对属性的方位进行一些控制
     应用场景：改变一个值时，同时改变其他的值


 ※ 实例：
    class Person{
      var age:Int = 0{
        willSet{  //隐藏参数 newValue，在值没改变之前且会被改变时调用
            print("你初始年龄age为：\(age)")  //0
            print("你设置的年龄newValue为：\(newValue)") //30
            //可以调用其他方法

        }
        didSet{ //隐藏参数 oldVlaue 在值改变后调用，此时值已经被改变，可判断其合法性，然后改变回去
            print("你设置后的年龄age为：\(age)")  //30
            print("你初始年龄oldValue为：\(oldValue)") //0

            if age>100 || age<0{
               //可以调用其他方法
            }else{
               //可以调用其他方法
            } 
        }
      }
    }

    willSet(newValue):被观察的属性即将被赋值之前自动调用改方法 newValue：新值,此时属性值还未被改变
    didSet(oldValue) :被观察的属性即将被赋值之后自动调用改方法 oldValue：旧值,此时属性值已经被改变


 ※ 注意点
     属性观察者不会再值的初始化阶段调用，比如在构造函数里初始化该值，就不会触发属性观察者.


---------------------------------------------------------------------------------------------------

