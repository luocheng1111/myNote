
 Java面向对象
----------------------------------------------------------------------------------------------------------------------------------
  三大特性：封装、继承、多态

  封装
   对外部不可见
  继承
   扩展类的功能
  多态
   方法的重写及重载
   对象的多态性

-----------------------------------------------------------------------------------------------------------------------------------   


 封装
----------------------------------------------------------------------------------------------------------------------------------
   作用域        当前类     同一package    子孙类      其他package
   private         √            ×            ×             ×
   friendly        √            √            ×             ×
   protected       √            √            √             ×
   public          √            √            √             √
   不写时默认为friendly
 
----------------------------------------------------------------------------------------------------------------------------------


 继承 extends：
----------------------------------------------------------------------------------------------------------------------------------
  基本概念：子类继承父类，可以扩展父类的功能，拥有父类的属性和方法.            
  
  继承的限制：
    1.只能单继承，不能多继承。但允许多层继承
    2.父类中的私有属性和方法，子类不能直接访问
  
  覆写：子类定义了与父类同名的方法，但覆写的方法访问权限必须等于或高于父类

  super关键字：表示从子类调用父类中的指定操作。

----------------------------------------------------------------------------------------------------------------------------------


 多态
----------------------------------------------------------------------------------------------------------------------------------
  多态性：多态性在java中有两种体现方法 1.方法的重载和覆写  2.对象的多态性
  
  方法覆写与重载的区别？
    1.覆写发生在父子类之间，重载发生在同类之间
    2.覆写要求方法名称，参数类型，返回值相同。重载只要求方法名称相同
    3.覆写要求被覆写的方法不能拥有更严格的权限，而重载没有要求

  对象的多态性主要分为以下两种类型
    1。向上转型：子类对象 -> 父类对象
        eg：父类 父类对象 =  子类实例
    2。向下转型：父类对象 -> 子类对象
        eg：子类 子类对象 =  (子类)父类实例；

  对象的向上转型关系： 如果是向上转型，当调用方法的子类覆写过的方法时，调用的
                       是被覆写过的方法，如果没有覆写，则调用本类的方法。转型之后，因为操作的是父类对象，
                       所以不能调用子类的方法

  对象的向下转型关系： 如果想产生对象的向下转型，则必须先产生一个向上转型关系，

  
  向上转型和向下转型有什么用？
     Person 可以表示为一个抽象的东西 就是人。比如说人可以唱歌, 就好比Person类中有一个sing方法. 
     当 Person p = new Man();  p.sing();  这个时候就是调用男人唱歌的sing方法
     当 Person p = new Woman(); p.sing();  这个时候就是调用女人的唱歌的sing方法
     这样其实就是一个java的继承,多态.  利于程序扩展.   你需要理解这种设计方式，会让你写出更易维护，简洁的代码。  

-----------------------------------------------------------------------------------------------------------------------------------   


 static 关键字    
----------------------------------------------------------------------------------------------------------------------------------
  作用：static可以声明属性和方法

  static声明属性
   static声明的属性称为全局或静态属性，保存在全局数据区中。可以类名.属性直接调用
  
  static声明方法
   如果一个方法使用了static关键字声明，则此方法可以直接使用类名称进行调用

  注意点：
   static声明的方法里，不能调用非static的属性或方法
   为什么？
   因为static声明的属性或方法，可以在对象没有实例化的时候就可以直接调用了
  
-----------------------------------------------------------------------------------------------------------------------------------   
 
 
 final 关键字
----------------------------------------------------------------------------------------------------------------------------------
  定义：final在Java中表示最终的意思，也可称为完结器。

  final的使用
   1.final声明的类不能有子类。
   2.final声明的方法不能被子类覆写
   3.使用final定义的变量成为常量，常量不可修改。且常量的命名要求都为大写
  
  public static final String NAME = “Lc”； 这样的声明表示全局常量。

  final，finally, finalize的区别。
   final用于声明类，方法，属性，分别表面类不可继承，方法不可覆写，属性不可变。
   finally与异常处理有关，和try/catch配合使用。
   finalize与Java的垃圾收集器有关。

----------------------------------------------------------------------------------------------------------------------------------


 instanceof 关键字
----------------------------------------------------------------------------------------------------------------------------------
  作用：在java中，instanceof关键字用于判断一个对象到底是否为某个类的实例
  规则：对象 instanceof 类     返回值为boolean

----------------------------------------------------------------------------------------------------------------------------------



 抽象类 abstract
----------------------------------------------------------------------------------------------------------------------------------
 基本概念：
  抽象类：包含一个抽象方法的类就是抽象类
  抽象方法：只声明而未实现的方法称为抽象方法，抽象方法必须使用abstract关键字声明
            (未声明的方法：public void fun();)
 
  抽象类的使用规则：
   1.抽象类不能直接实例化
   2.抽象类必须被子类继承，子类(若不是抽象类)必须覆写抽象类中的全部抽象方法
   
----------------------------------------------------------------------------------------------------------------------------------


 接口类 interface
----------------------------------------------------------------------------------------------------------------------------------
 基本概念：
  接口类：可以理解为一个特殊的类，里面全部由全局常量和公共的抽象方法组成
  定义简化：eg: String NAME = "lc" 等价于 public static final String NAME = "lc";
                void print();      等价于 public abstract void print();

 接口类的使用规则
   1.接口不能实例化，一个子类可以实现(implements关键字)多个接口，子类必须覆写全部的抽象方法，若子类不是抽象类的话
   2.一个抽象类可以实现一个接口，那么对于抽象类的子类则必须同时覆写接口类和抽象类中所有定义的抽象方法
   3.一个接口类不能继承一个抽象类，但是可以通过extends关键字继承多个接口

----------------------------------------------------------------------------------------------------------------------------------




 多线程
----------------------------------------------------------------------------------------------------------------------------------
 http://www.cnblogs.com/riskyer/p/3263032.html

 线程和进程的基本概念：
 进程：进程是指一个内存中运行的应用程序，每个进程都有自己独立的一块内存空间，一个进程中可以启动多个线程，
       如在Windows中，一个运行的exe就是一个进程
 线程：指进程中的一个执行流程，一个进程中可以运行多个线程，比如java.exe进程中可以运行很多线程，线程总是属于
       某个进程，进程中的多个线程共享进程的内存：

 “同时”执行是人的感觉，在线程之间实际上轮换执行。


 线程的创建与启动 两种方式
 1). 实现Runnable接口 new Thread(runnable).start();
 2). 继承Thread类 new Thread().start

 
 线程状态的转换
 线程状态：线程可分为五大状态,分别是生、死、可运行、运行、等待/阻塞
 1.新状态：线程对象已经创建，还没有在其上调用start()方法，
 2.可运行状态：start()方法调用时，线程首先进入可运行状态，
               在线程运行之后或者从阻塞/等待/睡眠状态回来后，也返回可运行状态
 3.运行状态：线程调度程序从可运行池中选择一个线程作为当前线程所处的状态
 4.等待/阻塞/睡眠状态：线程任就是活的，但是当前没有条件去运行
 5.死亡状态：当run()完成时就认为它死去，线程一旦死亡，就不能复生，如果在死去的线程上调用start()方法，会抛出异常


 阻止线程执行， 
 1.睡眠
   Thread.sleep(long millis)和Thread.sleep(long millis, int nanos)
   当线程睡眠时，它入睡在某个地方，在苏醒前不会返回可运行状态，睡眠时间到期，返回可运行状态
  
 2.线程优先级
   线程优先级：优先范围1~10， 优先级越高调用几率越大
   设置线程的优先级：Thread thread = new Thread(); t.setPriority(8); t.start();
	             线程的默认优先级是5，其中有三个常量定义优先级范围
		     static int MAX_PRIORITY 最高优先级
		     static int MIN_PRIORITY 最低优先级
		     static int NORM_PRIORITY 默认优先级

 3.线程让步
   Thread.yield(), 作用是暂停当前正在执行的线程对象，并执行其他线程，
		   在大多数情况下，yield()将导致线程从运行状态转向可运行状态，但有可能没有效果

 4.join()方法
   Thread的非静态方法join()让一个线程B"加入"到另外一个线程A的尾部，在A执行完毕之前，B不能工作
   eg:Thread t = new MyThread();
      t.start();
      t.join();
   另外, join还有一个方法 join(5000); 让线程等待5000毫秒，如果超过这个时间，则停止等待，变为可运行状态


 线程的同步与锁 synchronized关键字

  非静态synchronized方法时，获取的是对象锁
   public synchronized int getX() {
        return x++;
   }
   等价于
   public int getX() {
       synchronized (this) {
           return x;
       }
   }

  静态synchronized方法时,获取的是整个类对象的锁(XXX.class)
   public static synchronized int setName(String name){
      Xxx.name = name;
   }
   等价于
   public static int setName(String name){
      synchronized(Xxx.class){
            Xxx.name = name;
      }
   }

   注意点：
   1.只能同步方法，不能同步变量和类；
   2.如果线程持有同步和非同步方法，则非同步方法可以被多个线程自由访问而不受锁的限制
   3.线程睡眠时，它所持的任何锁都不会释放
   4.同步损害并发性，应该尽可能缩小同步范围，同步不但可以同步整个方法，还可以同步方法中的代码块

----------------------------------------------------------------------------------------------------------------------------------

